---
title: "230_final"
output: html_document
date: "2025-05-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# EDA
```{r}
library(dplyr)
library(ggplot2)
```

```{r}
# Load the dataset
df <- read.csv("hdb_with_mrt_info.csv")

# Check missing values and unique values for each column
eda_summary <- data.frame(
  missing_values = sapply(df, function(x) sum(is.na(x))),
  unique_values = sapply(df, function(x) length(unique(x)))
)

print(eda_summary)
```

```{r}
# Select the relevant columns
subset_df <- df[, c("latitude", "longitude", "address", "postal", "nearest_mrt_distance")]

# Check how many unique rows there are in the subset
unique_combinations <- nrow(unique(subset_df))
cat("Number of unique combinations:", unique_combinations, "\n")

```

We found that features like latitude, longitude, address, postal, nearest_mrt_distance actually have a one-to-one spatial correspondence. These columns jointly define a location and many columns are actually redundant.

```{r}
# check data type of each column
column_names <- names(df)
column_classes <- sapply(df, class)
type_df <- data.frame(
  column = column_names,
  data_type = unname(column_classes),
  row.names = NULL
)
print(type_df)
```

```{r}
# check feature relationship with label
# boxplot for year
ggplot(df, aes(x = factor(year), y = resale_price)) +
  geom_boxplot(outlier.alpha = 0.1) +
  labs(title = "Resale Price by Year", x = "Year", y = "Resale Price") +
  theme_minimal()

summary_year <- df %>%
  group_by(year) %>%
  summarise(
    min_price = min(resale_price, na.rm = TRUE),
    q1_price = quantile(resale_price, 0.25, na.rm = TRUE),
    median_price = median(resale_price, na.rm = TRUE),
    mean_price = mean(resale_price, na.rm = TRUE),
    q3_price = quantile(resale_price, 0.75, na.rm = TRUE),
    max_price = max(resale_price, na.rm = TRUE),
    count = n()
  )

print(summary_year)
```

```{r}

# boxplot for remaining_lease_years
ggplot(df, aes(x = factor(remaining_lease_years), y = resale_price)) +
  geom_boxplot(outlier.alpha = 0.1) +
  labs(title = "Resale Price by Remaining Lease Years", x = "Remaining Lease Years", y = "Resale Price") +
  theme_minimal()

summary_remaining_lease_years <- df %>%
  group_by(remaining_lease_years) %>%
  summarise(
    min_price = min(resale_price, na.rm = TRUE),
    q1_price = quantile(resale_price, 0.25, na.rm = TRUE),
    median_price = median(resale_price, na.rm = TRUE),
    mean_price = mean(resale_price, na.rm = TRUE),
    q3_price = quantile(resale_price, 0.75, na.rm = TRUE),
    max_price = max(resale_price, na.rm = TRUE),
    count = n()
  )

print(summary_remaining_lease_years)
```

```{r}
# Scatterplot for floor_area_sqm
ggplot(df, aes(x = floor_area_sqm, y = resale_price)) +
  geom_point(shape = 20, size = 1, alpha = 0.3) +
  labs(title = "Resale Price vs Floor Area", x = "Floor Area (sqm)", y = "Resale Price") +
  theme_minimal()

# Scatterplot for nearest_mrt_distance
ggplot(df, aes(x = nearest_mrt_distance, y = resale_price)) +
  geom_point(shape = 20, size = 1, alpha = 0.3) +
  labs(title = "Resale Price vs Distance to Nearest MRT", x = "Distance to MRT", y = "Resale Price") +
  theme_minimal()

```

```{r}
# Bin floor_area_sqm and generate boxplot
floor_min <- floor(min(df$floor_area_sqm, na.rm = TRUE))
floor_max <- ceiling(max(df$floor_area_sqm, na.rm = TRUE))
floor_breaks <- seq(floor_min, floor_max + 10, by = 10)

df$floor_bin <- cut(df$floor_area_sqm,
                    breaks = floor_breaks,
                    right = FALSE,
                    include.lowest = TRUE)

ggplot(df, aes(x = floor_bin, y = resale_price)) +
  geom_boxplot(outlier.alpha = 0.1) +
  labs(title = "Resale Price by Floor Area (Binned)", 
       x = "Floor Area (sqm)", y = "Resale Price") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Bin nearest_mrt_distance and generate boxplot
mrt_min <- floor(min(df$nearest_mrt_distance, na.rm = TRUE))
mrt_max <- ceiling(max(df$nearest_mrt_distance, na.rm = TRUE))
mrt_breaks <- seq(mrt_min, mrt_max + 200, by = 200)  

df$mrt_bin <- cut(df$nearest_mrt_distance, breaks = mrt_breaks, right = FALSE, include.lowest = TRUE)

ggplot(df, aes(x = mrt_bin, y = resale_price)) +
  geom_boxplot(outlier.alpha = 0.1) +
  labs(title = "Resale Price by Distance to Nearest MRT (Binned)", 
       x = "Distance to MRT (meters)", y = "Resale Price") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
# Town
ggplot(df, aes(x = town, y = resale_price)) +
  geom_boxplot(outlier.alpha = 0.1) +
  labs(title = "Resale Price by Town", x = "Town", y = "Resale Price") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

summary_town <- df %>%
  group_by(town) %>%
  summarise(
    min_price = min(resale_price, na.rm = TRUE),
    q1_price = quantile(resale_price, 0.25, na.rm = TRUE),
    median_price = median(resale_price, na.rm = TRUE),
    mean_price = mean(resale_price, na.rm = TRUE),
    q3_price = quantile(resale_price, 0.75, na.rm = TRUE),
    max_price = max(resale_price, na.rm = TRUE),
    count = n()
  )

print(summary_town)
```

```{r}
# flat_type
flat_type_levels <- c("1 ROOM", "2 ROOM", "3 ROOM", "4 ROOM", 
                      "5 ROOM", "EXECUTIVE", "MULTI-GENERATION")
df$flat_type <- factor(df$flat_type, levels = flat_type_levels)
ggplot(df, aes(x = flat_type, y = resale_price)) +
  geom_boxplot(outlier.alpha = 0.1) +
  labs(title = "Resale Price by Flat Type (Ordered)", 
       x = "Flat Type", y = "Resale Price") +
  theme_minimal()



summary_flat_type <- df %>%
  group_by(flat_type) %>%
  summarise(
    min_price = min(resale_price, na.rm = TRUE),
    q1_price = quantile(resale_price, 0.25, na.rm = TRUE),
    median_price = median(resale_price, na.rm = TRUE),
    mean_price = mean(resale_price, na.rm = TRUE),
    q3_price = quantile(resale_price, 0.75, na.rm = TRUE),
    max_price = max(resale_price, na.rm = TRUE),
    count = n()
  )

print(summary_flat_type)
```

```{r}

# storey_range
ggplot(df, aes(x = storey_range, y = resale_price)) +
  geom_boxplot(outlier.alpha = 0.1) +
  labs(title = "Resale Price by Storey Range", x = "Storey Range", y = "Resale Price") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

summary_storey_range <- df %>%
  group_by(storey_range) %>%
  summarise(
    min_price = min(resale_price, na.rm = TRUE),
    q1_price = quantile(resale_price, 0.25, na.rm = TRUE),
    median_price = median(resale_price, na.rm = TRUE),
    mean_price = mean(resale_price, na.rm = TRUE),
    q3_price = quantile(resale_price, 0.75, na.rm = TRUE),
    max_price = max(resale_price, na.rm = TRUE),
    count = n()
  )

print(summary_storey_range)
```

```{r}
# distance_from_expressway
ggplot(df, aes(x = distance_from_expressway, y = resale_price)) +
  geom_boxplot(outlier.alpha = 0.1) +
  labs(title = "Resale Price by Distance from Expressway", x = "Distance from Expressway", y = "Resale Price") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

summary_distance_from_expressway <- df %>%
  group_by(distance_from_expressway) %>%
  summarise(
    min_price = min(resale_price, na.rm = TRUE),
    q1_price = quantile(resale_price, 0.25, na.rm = TRUE),
    median_price = median(resale_price, na.rm = TRUE),
    mean_price = mean(resale_price, na.rm = TRUE),
    q3_price = quantile(resale_price, 0.75, na.rm = TRUE),
    max_price = max(resale_price, na.rm = TRUE),
    count = n()
  )

print(summary_distance_from_expressway)
```

```{r}
# num_nearby_mrts
ggplot(df, aes(x = factor(num_nearby_mrts), y = resale_price)) +
  geom_boxplot(outlier.alpha = 0.1) +
  labs(title = "Resale Price by Number of Nearby MRTs", x = "Number of Nearby MRT Stations", y = "Resale Price") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

summary_num_nearby_mrts <- df %>%
  group_by(num_nearby_mrts) %>%
  summarise(
    min_price = min(resale_price, na.rm = TRUE),
    q1_price = quantile(resale_price, 0.25, na.rm = TRUE),
    median_price = median(resale_price, na.rm = TRUE),
    mean_price = mean(resale_price, na.rm = TRUE),
    q3_price = quantile(resale_price, 0.75, na.rm = TRUE),
    max_price = max(resale_price, na.rm = TRUE),
    count = n()
  )

print(summary_num_nearby_mrts)
```

```{r}
# distribution of resale price
ggplot(df, aes(x = resale_price)) +
  geom_histogram(aes(y = ..density..), bins = 60, fill = "skyblue", color = "white", alpha = 0.7) +
  geom_density(color = "darkblue", size = 1) +
  labs(title = "Distribution of Resale Price", x = "Resale Price (SGD)", y = "Density") +
  theme_minimal()

# distibution of log(resale_price)
ggplot(df, aes(x = log(resale_price))) +
  geom_histogram(aes(y = ..density..), bins = 60, fill = "lightblue", color = "white", alpha = 0.7) +
  geom_density(color = "darkblue", size = 1) +
  labs(title = "Distribution of Log-Transformed Resale Price", 
       x = "log(Resale Price)", y = "Density") +
  theme_minimal()

# Q-Q plot for original resale_price
qqnorm(df$resale_price, main = "Q-Q Plot of Resale Price")
qqline(df$resale_price, col = "red", lwd = 2)

# Q-Q plot for log-transformed resale_price
qqnorm(log(df$resale_price), main = "Q-Q Plot of Log-Transformed Resale Price")
qqline(log(df$resale_price), col = "blue", lwd = 2)
```
```{r}
# Compute correlation matrix for numeric columns
library(corrplot)
numeric_df <- df %>%
  select(where(is.numeric))
cor_matrix <- cor(numeric_df, use = "complete.obs", method = "pearson")
corrplot(cor_matrix, method = "color", type = "upper", 
         tl.cex = 0.8, addCoef.col = "black", number.cex = 0.7)
```

```{r}
street_counts <- df %>%
  count(street_name)

# Filter to keep only street names with at least 100 observations
valid_streets <- street_counts %>%
  filter(n >= 100) %>%
  pull(street_name)

df <- df %>%
  filter(street_name %in% valid_streets)

num_unique_streets <- n_distinct(df$street_name)
print(num_unique_streets)
```






# Feature Engineering
```{r}
library(caret)

# Apply one-hot encoding to town and street_name
df$town <- factor(df$town)
df$street_name <- factor(df$street_name)

# set reference category
df$town <- relevel(df$town, ref = "ANG MO KIO")
df$street_name <- relevel(df$street_name, ref = "ANG MO KIO AVENUE 10")

town_oh <- model.matrix(~ town, data = df)[, -1]       
street_oh <- model.matrix(~ street_name, data = df)[, -1]
```




```{r}
# apply ordinal encoding to flat_type
flat_order <- c("1 ROOM", "2 ROOM", "3 ROOM", "4 ROOM", "5 ROOM", "EXECUTIVE", "MULTI-GENERATION")
df$flat_type_ord <- as.numeric(factor(df$flat_type, levels = flat_order, ordered = TRUE))

# apply ordinal encoding to distance_from_expressway
expressway_levels <- c("<=50m", "51-100m", "101-150m", 
                       "151-300m", "301-500m", ">500m")
df$distance_expressway_ord <- as.numeric(factor(df$distance_from_expressway, 
                                                levels = expressway_levels, ordered = TRUE))


# apply ordinal encoding to storey_range
storey_levels <- c("01 TO 03", "04 TO 06", "07 TO 09", "10 TO 12", "13 TO 15",
                   "16 TO 18", "19 TO 21", "22 TO 24", "25 TO 27", "28 TO 30",
                   "31 TO 33", "34 TO 36", "37 TO 39", "40 TO 42", "43 TO 45",
                   "46 TO 48", "49 TO 51")
df$storey_range_ord <- as.numeric(factor(df$storey_range,
                                         levels = storey_levels, ordered = TRUE))

```

```{r}
# Combine encoded features
df_encoded <- cbind(
  df,
  town_oh,
  street_oh
)

# Drop unused raw categorical and spatial features
drop_cols <- c("town", "flat_type", "block", "street_name", "storey_range", 
               "storey_range_category", "distance_from_expressway", "latitude", 
               "longitude", "address", "postal", "nearest_mrt", "floor_bin", "mrt_bin")
df_encoded <- df_encoded[, !(colnames(df_encoded) %in% drop_cols)]

#  Train/test split
set.seed(123)
train_idx <- createDataPartition(df_encoded$resale_price, p = 0.8, list = FALSE)
train <- df_encoded[train_idx, ]
test <- df_encoded[-train_idx, ]

# Create X and Y for modeling
y_train <- train$resale_price
X_train <- train[, setdiff(names(train), "resale_price")]

y_test <- test$resale_price
X_test <- test[, setdiff(names(test), "resale_price")]

```

# Modeling
```{r}
# OLS 
train_df <- data.frame(y_train = y_train, X_train)
test_df <- data.frame(X_test)

model_ols <- lm(y_train ~ ., data = train_df)
summary(model_ols)



# Predict on test set
y_pred <- predict(model_ols, newdata = test_df)
mse <- mean((y_test - y_pred)^2)
cat("Test MSE (OLS):", round(mse, 2), "\n")
```

## regularized approach
```{r}
library(glmnet)
set.seed(123)

# Split train set into two halves
n <- nrow(X_train)
idx <- sample(seq_len(n), size = floor(0.5 * n))
X_train1 <- X_train[idx, ]
y_train1 <- y_train[idx]
X_train2 <- X_train[-idx, ]
y_train2 <- y_train[-idx]

X_train1_mat <- as.matrix(X_train1)
X_train2_mat <- as.matrix(X_train2)
X_test_mat   <- as.matrix(X_test)

# Fit LASSO on first half
cvfit <- cv.glmnet(X_train1_mat, y_train1, alpha = 1, standardize = TRUE)
best_lambda <- cvfit$lambda.min

# Get non-zero coefficients
lasso_model <- glmnet(X_train1_mat, y_train1, alpha = 1, lambda = best_lambda, standardize = TRUE)
selected_vars <- which(coef(lasso_model)[-1] != 0)  # exclude intercept

# Filter non-zero coefficients in second half and refit OLS
X_train2_sel <- X_train2_mat[, selected_vars, drop = FALSE]
X_test_sel   <- X_test_mat[, selected_vars, drop = FALSE]

train2_df <- data.frame(y = y_train2, X = X_train2_sel)
test_sel_df <- data.frame(X = X_test_sel)

model_refit <- lm(y ~ ., data = train2_df)
summary(model_refit)

# Predict on test set
y_pred_lasso <- predict(model_refit, newdata = test_sel_df)
mse_lasso <- mean((y_test - y_pred_lasso)^2)
cat("Test MSE (Refit LASSO):", round(mse_lasso, 2), "\n")
```
## log-transform
```{r}
log_y_train <- log(y_train)
log_y_test  <- log(y_test)

train_log_df <- data.frame(log_y = log_y_train, X_train)
test_df <- data.frame(X_test)

model_log_ols <- lm(log_y ~ ., data = train_log_df)
summary(model_log_ols)

# Predict on test set (log scale)
log_y_pred <- predict(model_log_ols, newdata = test_df)

# transform back to original scale
y_pred <- exp(log_y_pred)

# Compute MSE on original price scale
mse_log_ols <- mean((y_test - y_pred)^2)
cat("Test MSE (log-OLS back-transformed):", round(mse_log_ols, 2), "\n")
```

### Gamma regression
```{r}
model_gamma <- glm(y_train ~ ., family = Gamma(link = "log"), data = train_df)
summary(model_gamma)

# Predict on test set on original scale
y_pred_gamma <- predict(model_gamma, newdata = test_df, type = "response")

# Compute test MSE
mse_gamma <- mean((y_test - y_pred_gamma)^2)
cat("Test MSE (Gamma regression):", round(mse_gamma, 2), "\n")
```


### proportional odds logistic model


```{r}
library(MASS)
# Create decile-based bins
deciles <- quantile(y_train, probs = seq(0, 1, by = 0.1))
deciles[duplicated(deciles)] <- deciles[duplicated(deciles)] + 1

# Cut y_train into ordinal categories 1 to 10
y_train_ord <- cut(y_train, breaks = deciles, include.lowest = TRUE, labels = FALSE)
y_train_ord <- factor(y_train_ord, ordered = TRUE)

#  Create train_df with ordinal response
train_ord_df <- data.frame(y_ord = y_train_ord, X_train)

# Fit proportional odds logistic regression
model_polr <- polr(y_ord ~ ., data = train_ord_df, method = "logistic", Hess = TRUE)
summary(model_polr)

```















